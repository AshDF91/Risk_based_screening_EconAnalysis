## Adapted code from DARTH group for Markov microsimulation to this breast cancer setting ##

library(darthtools) 

##################################### Model input #######################################
# Model input
n.i   <- 1000000                    # number of simulated individuals
n.t   <- 25                         # time horizon, number of cycles 
v.n   <- c("No cancer","Local breast cancer","Regional breast cancer","Metastatic breast cancer", "Breast cancer death", "Other cause death")  # the model states
n.s   <- length(v.n)                # the number of health states
v.M_1 <- rep("No cancer", n.i)      # everyone begins in the healthy state - will need to change this for stratified MicroSim (risk based screening ones) 
d.c   <- d.e <- 0.035               # equal discounting of costs and QALYs by 3.5%
#v.Trt <- c("No screening", "Screening", "Risk-based screening") # store the strategy names

# Transition probabilities (per cycle)
p.healthy_local_cancer       <- 0.005               # probability to die when healthy
p.healthy_regional_cancer    <- 0.004               # No breast cancer to regional breast cancer 
p.healthy_metastatic_cancer  <- 0.001               # No breast cancer to advanced cancers (mets) 
p.healthy_other_death        <- 0.001               # No breast cancer to non-breast cancer death

p.local_breast_death         <- 0.005               # Local breast cancer to breast cancer death 
p.local_other_death          <- 0.009


p.regional_breast_death      <- 0.010
p.regional_other_death       <- 0.011

p.metastatic_breast_death    <- 0.3 
p.metastatic_other_death     <- 0.1

# Cost and utility inputs 
c.healthy                    <- 2000             
c.local_cancer               <- 4000             
c.regional_cancer            <- 15000            
c.metastatic_cancer          <- 22000            

u.healthy                    <- 1                   
u.local_cancer               <- 0.75                
u.regional_cancer            <- 0.5              
u.metastatic_cancer          <- 0.25  


##########################################################################################
##########################################################################################


## Using samplev from DARTH ##

samplev <- function (probs, m) {
  d <- dim(probs)
  n <- d[1]
  k <- d[2]
  lev <- dimnames(probs)[[2]]
  if (!length(lev)) 
    lev <- 1:k
  ran <- matrix(lev[1], ncol = m, nrow = n)
  U <- t(probs)
  for(i in 2:k) {
    U[i, ] <- U[i, ] + U[i - 1, ]
  }
  if (any((U[k, ] - 1) > 1e-05))
    stop("error in multinom: probabilities do not sum to 1")
  
  for (j in 1:m) {
    un <- rep(runif(n), rep(k, n))
    ran[, j] <- lev[1 + colSums(un > U)]
  }
  ran
}



# The MicroSim2 functions for the Markov microsimulation #
MicroSim2 <- function(v.M_1, n.i, n.t, v.n, d.c, d.e, TR.out = TRUE, TS.out = TRUE, seed = 1982) {   
  # Arguments:  
  # v.M_1:   vector of initial states for individuals 
  # n.i:     number of individuals
  # n.t:     total number of cycles to run the model
  # v.n:     vector of health state names
  # X:       vector or matrix of individual characteristics
  # d.c:     discount rate for costs
  # d.e:     discount rate for health outcomes (QALYs)
  # TR.out:  should the output include a microsimulation trace? (default is TRUE)
  # TS.out:  should the output include a matrix of transitions between states? (default is TRUE)
  
  # seed:    starting seed number for random number generator (default is 1)
  # Makes use of:
  # Probs:   function for the estimation of transition probabilities
  # Costs:   function for the estimation of cost state values
  # Effs:    function for the estimation of state specific health outcomes (QALYs)
  
  v.dwc <- 1 / ((1 + d.c) ^ (0:n.t))   # calculate the cost discount weight based on the discount rate d.c
  v.dwe <- 1 / ((1 + d.e) ^ (0:n.t))   # calculate the QALY discount weight based on the discount rate d.e
  
  # create the matrix capturing the state name/costs/health outcomes for all individuals at each time point 
  m.M <- m.C <- m.E <- matrix(nrow = n.i, ncol = n.t + 1,
                              dimnames = list(paste("ind",   1:n.i, sep =" "),
                                              paste("cycle", 0:n.t, sep =" "))) 
  
  m.M[, 1] <- v.M_1            
  
  set.seed(seed) 
  
  m.C[, 1] <- Costs(m.M[, 1])       
  m.E[, 1] <- Effs(m.M[, 1])  
  
  
  for (t in 1:n.t) {
    
    m.p <- Probs(m.M[, t]) 
    
    m.M[, t + 1] <- samplev( prob = m.p, m = 1)  # sample the next health state and store that state in matrix m.M 
    m.C[, t + 1] <- Costs(m.M[, t + 1])   # estimate costs per individual during cycle t + 1 
    m.E[, t + 1] <- Effs( m.M[, t + 1])   # estimate QALYs per individual during cycle t + 1 
    cat('\r', paste(round(t/n.t * 100), "% done", sep = " "))       # display the progress of the simulation
    
  }
  
  tc <- m.C %*% v.dwc       # total (discounted) cost per individual
  te <- m.E %*% v.dwe       # total (discounted) QALYs per individual 
  
  tc_hat <- mean(tc)        # average (discounted) cost 
  te_hat <- mean(te)        # average (discounted) QALYs
    
  if (TS.out == TRUE) {  # create a matrix of transitions across states
    TS <- paste(m.M, cbind(m.M[, -1], NA), sep = "->") # transitions from one state to the other
    TS <- matrix(TS, nrow = n.i)
    rownames(TS) <- paste("Ind",   1:n.i, sep = " ")   # name the rows 
    colnames(TS) <- paste("Cycle", 0:n.t, sep = " ")   # name the columns 
  } else {
    TS <- NULL
  }
  
  if (TR.out == TRUE) {
    TR <- t(apply(m.M, 2, function(x) table(factor(x, levels = v.n, ordered = TRUE))))
    TR <- TR / n.i                                       # create a distribution trace
    rownames(TR) <- paste("Cycle", 0:n.t, sep = " ")     # name the rows 
    colnames(TR) <- v.n                                  # name the columns 
  } else {
    TR <- NULL
  }
  results <- list(m.M = m.M, m.C = m.C, m.E = m.E, tc = tc, te = te, tc_hat = tc_hat, te_hat = te_hat, TS = TS, TR = TR) # store the results from the simulation in a list  
  return(results)  # return the results
}  # end of the MicroSim2 function  


#### Probability function
# The Probs function that updates the transition probabilities of every cycle is shown below.

Probs <- function(M_it) { 
  # M_it:        health state occupied by individual i at cycle t (character variable)

  m.p.it <- matrix(NA, n.s, n.i)     # create vector of state transition probabilities
  rownames(m.p.it) <- v.n            # name the vector
  
  # update v.p.it with the appropriate probabilities   
  m.p.it[,M_it ==  "No cancer"]                 <- c(1 - p.healthy_local_cancer - p.healthy_regional_cancer - p.healthy_metastatic_cancer - p.healthy_other_death, p.healthy_local_cancer,                            p.healthy_regional_cancer,                            p.healthy_metastatic_cancer,                              0,                          p.healthy_other_death)
  m.p.it[,M_it ==  "Local breast cancer"]       <- c(0,                                                                                                            1 - p.local_breast_death - p.local_other_death,    0,                                                    0,                                                        p.local_breast_death,       p.local_other_death)
  m.p.it[,M_it ==  "Regional breast cancer"]    <- c(0,                                                                                                            0,                                                 1 - p.regional_breast_death - p.regional_other_death, 0,                                                        p.regional_breast_death,    p.regional_other_death)
  m.p.it[,M_it ==  "Metastatic breast cancer"]  <- c(0,                                                                                                            0,                                                 0,                                                    1 - p.metastatic_breast_death - p.metastatic_other_death, p.metastatic_breast_death,  p.metastatic_other_death)
  m.p.it[,M_it ==  "Breast cancer death"]       <- c(0,                                                                                                            0,                                                 0,                                                    0,                                                        1,                          0)
  m.p.it[,M_it ==  "Other cause death"]         <- c(0,                                                                                                            0,                                                 0,                                                    0,                                                        0,                          1)

  ifelse(colSums(m.p.it) == 1, return(t(m.p.it)), print("Probabilities do not sum to 1")) # return the transition probabilities or produce an error
}    

### Costs function
# The Costs function estimates the costs at every cycle for the extended microsimulaton.

Costs <- function (M_it) {  
  # M_it: health state occupied by individual i at cycle t (character variable)

  c.it                                     <- 0
  c.it[M_it == "No cancer"]                <- c.healthy 
  c.it[M_it == "Local breast cancer"]      <- c.local_cancer
  c.it[M_it == "Regional breast cancer"]   <- c.regional_cancer
  c.it[M_it == "Metastatic breast cancer"] <- c.metastatic_cancer
  c.it[M_it == "Breast cancer death"]      <- 0
  c.it[M_it == "Other cause death"]        <- 0
  return(c.it)                                # return the costs
  
}


### Health outcome function 
# The Effs function to update the utilities at every cycle for the extended microsimulaton.

Effs <- function (M_it, cl = 1) {   ## X = NULL
  # M_it: health state occupied by individual i at cycle t (character variable)
  # dur:  the duration of being sick/sicker
  # cl:   the cycle length (default = 1 )
  # X:    the vector or matrix of individual characteristics (optional)
  
  u.it               <- 0        # by default the utility for everyone is zero
  u.it[M_it == "No cancer"]                <- u.healthy
  u.it[M_it == "Local breast cancer"]      <- u.local_cancer
  u.it[M_it == "Regional breast cancer"]   <- u.regional_cancer
  u.it[M_it == "Metastatic breast cancer"] <- u.metastatic_cancer
  u.it[M_it == "Breast cancer death"]      <- 0 
  u.it[M_it == "Other cause death"]        <- 0 
  
  QALYs <- u.it * cl             # calculate the QALYs during cycle t
  return(QALYs)                  # return the results
}


## Start the simulation ##

start <- Sys.time() 
simulation2 <- MicroSim2(v.M_1, n.i, n.t, v.n, d.c, d.e)
end <- Sys.time() 

end-start        ## Takes about 5 seconds for 100,000. About 40 seconds for 1 million. 


################################################################################
################################################################################


# For later, once all the Markovs have run #

# store the mean costs (and the MCSE) of each strategy in a new variable C (vector costs)
v.C  <- c(simulation2$tc_hat, simulation3$tc_hat) 
sd.C <- c(sd(simulation2$tc), sd(simulation3$tc)) / sqrt(n.i)
# store the mean QALYs (and the MCSE) of each strategy in a new variable E (vector effects)
v.E  <- c(simulation2$te_hat, simulation3$te_hat)
sd.E <- c(sd(simulation2$te), sd(simulation3$te)) / sqrt(n.i)

delta.C <- v.C[2] - v.C[1]                   # calculate incremental costs
delta.E <- v.E[2] - v.E[1]                   # calculate incremental QALYs
sd.delta.E <- sd(simulation2$te - simulation3$te) / sqrt(n.i) # Monte Carlo Squared Error (MCSE) of incremental costs
sd.delta.C <- sd(simulation2$tc - simulation3$tc) / sqrt(n.i) # Monte Carlo Squared Error (MCSE) of incremental QALYs
ICER    <- delta.C / delta.E                 # calculate the ICER
results <- c(delta.C, delta.E, ICER)         # store the values in a new variable


# Create full incremental cost-effectiveness analysis table
table_micro <- data.frame(
  c(round(v.C, 0),  ""),           # costs per arm
  c(round(sd.C, 0), ""),           # MCSE for costs
  c(round(v.E, 3),  ""),           # health outcomes per arm
  c(round(sd.E, 3), ""),           # MCSE for health outcomes
  c("", round(delta.C, 0),   ""),  # incremental costs
  c("", round(sd.delta.C, 0),""),  # MCSE for incremental costs
  c("", round(delta.E, 3),   ""),  # incremental QALYs 
  c("", round(sd.delta.E, 3),""),  # MCSE for health outcomes (QALYs) gained
  c("", round(ICER, 0),      "")   # ICER
)
rownames(table_micro) <- c() #add in strategies#, "* are MCSE values")  # name the rows
colnames(table_micro) <- c("Costs", "*",  "QALYs", "*", "Incremental Costs", "*", "QALYs Gained", "*", "ICER") # name the columns
table_micro  # print the table 
